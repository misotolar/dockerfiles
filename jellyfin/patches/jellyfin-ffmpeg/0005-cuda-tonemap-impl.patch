diff -rupN ffmpeg-4.4.orig/compat/cuda/cuda_runtime.h ffmpeg-4.4/compat/cuda/cuda_runtime.h
--- ffmpeg-4.4.orig/compat/cuda/cuda_runtime.h	2021-07-17 18:49:01.434571296 +0200
+++ ffmpeg-4.4/compat/cuda/cuda_runtime.h	2021-07-17 18:53:23.389283764 +0200
@@ -1,7 +1,7 @@
 /*
  * Minimum CUDA compatibility definitions header
  *
- * Copyright (c) 2019 rcombs
+ * Copyright (c) 2019 Rodger Combs
  *
  * This file is part of FFmpeg.
  *
@@ -33,55 +33,67 @@
 #define max(a, b) ((a) > (b) ? (a) : (b))
 #define min(a, b) ((a) < (b) ? (a) : (b))
 #define abs(x) ((x) < 0 ? -(x) : (x))
+#define clamp(a, b, c) min(max((a), (b)), (c))
 
 #define atomicAdd(a, b) (__atomic_fetch_add(a, b, __ATOMIC_SEQ_CST))
 
 // Basic typedefs
 typedef __device_builtin__ unsigned long long cudaTextureObject_t;
 
-typedef struct __device_builtin__ __align__(2) uchar2
-{
-    unsigned char x, y;
-} uchar2;
-
-typedef struct __device_builtin__ __align__(4) ushort2
-{
-    unsigned short x, y;
-} ushort2;
-
-typedef struct __device_builtin__ uint3
-{
-    unsigned int x, y, z;
-} uint3;
-
-typedef struct uint3 dim3;
-
-typedef struct __device_builtin__ __align__(8) int2
-{
-    int x, y;
-} int2;
-
-typedef struct __device_builtin__ __align__(4) uchar4
-{
-    unsigned char x, y, z, w;
-} uchar4;
+#define MAKE_VECTORS(type, base) \
+typedef struct __device_builtin__ type##1 { \
+    base x; \
+} type##1; \
+static __inline__ __device__ type##1 make_##type##1(base x) { \
+    type##1 ret; \
+    ret.x = x; \
+    return ret; \
+} \
+typedef struct __device_builtin__ __align__(sizeof(base) * 2) type##2 { \
+    base x, y; \
+} type##2; \
+static __inline__ __device__ type##2 make_##type##2(base x, base y) { \
+    type##2 ret; \
+    ret.x = x; \
+    ret.y = y; \
+    return ret; \
+} \
+typedef struct __device_builtin__ type##3 { \
+    base x, y, z; \
+} type##3; \
+static __inline__ __device__ type##3 make_##type##3(base x, base y, base z) { \
+    type##3 ret; \
+    ret.x = x; \
+    ret.y = y; \
+    ret.z = z; \
+    return ret; \
+} \
+typedef struct __device_builtin__ __align__(sizeof(base) * 4) type##4 { \
+    base x, y, z, w; \
+} type##4; \
+static __inline__ __device__ type##4 make_##type##4(base x, base y, base z, base w) { \
+    type##4 ret; \
+    ret.x = x; \
+    ret.y = y; \
+    ret.z = z; \
+    ret.w = w; \
+    return ret; \
+}
 
-typedef struct __device_builtin__ __align__(8) ushort4
-{
-    unsigned short x, y, z, w;
-} ushort4;
+MAKE_VECTORS(uchar, unsigned char)
+MAKE_VECTORS(ushort, unsigned short)
+MAKE_VECTORS(int, int)
+MAKE_VECTORS(uint, unsigned int)
+MAKE_VECTORS(float, float)
 
-typedef struct __device_builtin__ __align__(16) int4
-{
-    int x, y, z, w;
-} int4;
+typedef struct __device_builtin__ uint3 dim3;
 
 // Accessors for special registers
 #define GETCOMP(reg, comp) \
     asm("mov.u32 %0, %%" #reg "." #comp ";" : "=r"(tmp)); \
     ret.comp = tmp;
 
-#define GET(name, reg) static inline __device__ uint3 name() {\
+#define GET(name, reg) static __inline__ __device__ uint3 name() {\
     uint3 ret; \
     unsigned tmp; \
     GETCOMP(reg, x) \
@@ -99,14 +111,8 @@ GET(getThreadIdx, tid)
 #define blockDim (getBlockDim())
 #define threadIdx (getThreadIdx())
 
-// Basic initializers (simple macros rather than inline functions)
-#define make_uchar2(a, b) ((uchar2){.x = a, .y = b})
-#define make_ushort2(a, b) ((ushort2){.x = a, .y = b})
-#define make_uchar4(a, b, c, d) ((uchar4){.x = a, .y = b, .z = c, .w = d})
-#define make_ushort4(a, b, c, d) ((ushort4){.x = a, .y = b, .z = c, .w = d})
-
 // Conversions from the tex instruction's 4-register output to various types
-#define TEX2D(type, ret) static inline __device__ void conv(type* out, unsigned a, unsigned b, unsigned c, unsigned d) {*out = (ret);}
+#define TEX2D(type, ret) static __inline__ __device__ void conv(type* out, unsigned a, unsigned b, unsigned c, unsigned d) {*out = (ret);}
 
 TEX2D(unsigned char, a & 0xFF)
 TEX2D(unsigned short, a & 0xFFFF)
@@ -117,15 +123,46 @@ TEX2D(ushort4, make_ushort4((unsigned sh
 
 // Template calling tex instruction and converting the output to the selected type
 template <class T>
-static inline __device__ T tex2D(cudaTextureObject_t texObject, float x, float y)
+static __inline__ __device__ T tex2D(cudaTextureObject_t texObject, float x, float y)
+{
+    T ret;
+    unsigned ret1, ret2, ret3, ret4;
+    asm("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" :
+        "=r"(ret1), "=r"(ret2), "=r"(ret3), "=r"(ret4) :
+        "l"(texObject), "f"(x), "f"(y));
+    conv(&ret, ret1, ret2, ret3, ret4);
+    return ret;
+}
+
+static __inline__ __device__ float __exp2f(float x)
+{
+    float ret;
+    asm("ex2.approx.f32 %0, %1;" : "=f"(ret) : "f"(x));
+    return ret;
+}
+
+#define __expf(x) (__log2f((x) * 1.4427f))
+
+static __inline__ __device__ float __log2f(float x)
+{
+    float ret;
+    asm("lg2.approx.f32 %0, %1;" : "=f"(ret) : "f"(x));
+    return ret;
+}
+
+#define __logf(x) (__log2f((x)) * 0.693147f)
+#define __log10f(x) (__log2f((x) * 0.30103f))
+
+static __inline__ __device__ float __powf(float x, float y)
+{
+    return __exp2f(y * __log2f(x));
+}
+
+static __inline__ __device__ float __sqrtf(float x)
 {
-  T ret;
-  unsigned ret1, ret2, ret3, ret4;
-  asm("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" :
-      "=r"(ret1), "=r"(ret2), "=r"(ret3), "=r"(ret4) :
-      "l"(texObject), "f"(x), "f"(y));
-  conv(&ret, ret1, ret2, ret3, ret4);
-  return ret;
+    float ret;
+    asm("sqrtf.approx.f32 %0, %1;" : "=f"(ret) : "f"(x));
+    return ret;
 }
 
-#endif /* COMPAT_CUDA_CUDA_RUNTIME_H */
+#endif
diff -rupN ffmpeg-4.4.orig/configure ffmpeg-4.4/configure
--- ffmpeg-4.4.orig/configure	2021-07-17 18:49:01.401237787 +0200
+++ ffmpeg-4.4/configure	2021-07-17 18:54:01.406150589 +0200
@@ -3057,6 +3057,8 @@ scale_cuda_filter_deps="ffnvcodec"
 scale_cuda_filter_deps_any="cuda_nvcc cuda_llvm"
 thumbnail_cuda_filter_deps="ffnvcodec"
 thumbnail_cuda_filter_deps_any="cuda_nvcc cuda_llvm"
+tonemap_cuda_filter_deps="ffnvcodec"
+tonemap_cuda_filter_deps_any="cuda_nvcc cuda_llvm"
 transpose_npp_filter_deps="ffnvcodec libnpp"
 overlay_cuda_filter_deps="ffnvcodec"
 overlay_cuda_filter_deps_any="cuda_nvcc cuda_llvm"
diff -rupN ffmpeg-4.4.orig/ffbuild/common.mak ffmpeg-4.4/ffbuild/common.mak
--- ffmpeg-4.4.orig/ffbuild/common.mak	2021-07-17 18:49:01.484571559 +0200
+++ ffmpeg-4.4/ffbuild/common.mak	2021-07-17 18:54:29.252963876 +0200
@@ -38,6 +38,7 @@ OBJCCFLAGS  = $(CPPFLAGS) $(CFLAGS) $(OB
 ASFLAGS    := $(CPPFLAGS) $(ASFLAGS)
 CXXFLAGS   := $(CPPFLAGS) $(CFLAGS) $(CXXFLAGS)
 X86ASMFLAGS += $(IFLAGS:%=%/) -I$(<D)/ -Pconfig.asm
+NVCCFLAGS  += $(IFLAGS)
 
 HOSTCCFLAGS = $(IFLAGS) $(HOSTCPPFLAGS) $(HOSTCFLAGS)
 LDFLAGS    := $(ALLFFLIBS:%=$(LD_PATH)lib%) $(LDFLAGS)
diff -rupN ffmpeg-4.4.orig/libavfilter/allfilters.c ffmpeg-4.4/libavfilter/allfilters.c
--- ffmpeg-4.4.orig/libavfilter/allfilters.c	2021-07-17 18:49:01.407904489 +0200
+++ ffmpeg-4.4/libavfilter/allfilters.c	2021-07-17 18:55:46.196703448 +0200
@@ -430,6 +430,7 @@ extern AVFilter ff_vf_tmedian;
 extern AVFilter ff_vf_tmidequalizer;
 extern AVFilter ff_vf_tmix;
 extern AVFilter ff_vf_tonemap;
+extern AVFilter ff_vf_tonemap_cuda;
 extern AVFilter ff_vf_tonemap_opencl;
 extern AVFilter ff_vf_tonemap_vaapi;
 extern AVFilter ff_vf_tpad;
diff -rupN ffmpeg-4.4.orig/libavfilter/colorspace.c ffmpeg-4.4/libavfilter/colorspace.c
--- ffmpeg-4.4.orig/libavfilter/colorspace.c	2021-07-17 18:49:01.407904489 +0200
+++ ffmpeg-4.4/libavfilter/colorspace.c	2021-07-17 18:57:31.870595322 +0200
@@ -17,6 +17,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "libavutil/avassert.h"
 #include "libavutil/frame.h"
 #include "libavutil/mastering_display_metadata.h"
 #include "libavutil/pixdesc.h"
@@ -138,6 +139,33 @@ const struct LumaCoefficients *ff_get_lu
     return coeffs;
 }
 
+static const struct PrimaryCoefficients color_primaries[AVCOL_PRI_NB] = {
+    [AVCOL_PRI_BT709]     = { 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 },
+    [AVCOL_PRI_BT470M]    = { 0.670, 0.330, 0.210, 0.710, 0.140, 0.080 },
+    [AVCOL_PRI_BT470BG]   = { 0.640, 0.330, 0.290, 0.600, 0.150, 0.060 },
+    [AVCOL_PRI_SMPTE170M] = { 0.630, 0.340, 0.310, 0.595, 0.155, 0.070 },
+    [AVCOL_PRI_SMPTE240M] = { 0.630, 0.340, 0.310, 0.595, 0.155, 0.070 },
+    [AVCOL_PRI_SMPTE428]  = { 0.735, 0.265, 0.274, 0.718, 0.167, 0.009 },
+    [AVCOL_PRI_SMPTE431]  = { 0.680, 0.320, 0.265, 0.690, 0.150, 0.060 },
+    [AVCOL_PRI_SMPTE432]  = { 0.680, 0.320, 0.265, 0.690, 0.150, 0.060 },
+    [AVCOL_PRI_FILM]      = { 0.681, 0.319, 0.243, 0.692, 0.145, 0.049 },
+    [AVCOL_PRI_BT2020]    = { 0.708, 0.292, 0.170, 0.797, 0.131, 0.046 },
+    [AVCOL_PRI_JEDEC_P22] = { 0.630, 0.340, 0.295, 0.605, 0.155, 0.077 },
+};
+
+const struct PrimaryCoefficients *ff_get_color_primaries(enum AVColorPrimaries prm)
+{
+    const struct PrimaryCoefficients *p;
+
+    if (prm >= AVCOL_PRI_NB)
+        return NULL;
+    p = &color_primaries[prm];
+    if (!p->xr)
+        return NULL;
+
+    return p;
+}
+
 void ff_fill_rgb2yuv_table(const struct LumaCoefficients *coeffs,
                            double rgb2yuv[3][3])
 {
@@ -165,6 +193,52 @@ void ff_fill_rgb2yuv_table(const struct
     rgb2yuv[2][2] = rscale * coeffs->cb;
 }
 
+int ff_get_range_off(int *off, int *y_rng, int *uv_rng,
+                     enum AVColorRange rng, int depth)
+{
+    switch (rng) {
+    case AVCOL_RANGE_UNSPECIFIED:
+    case AVCOL_RANGE_MPEG:
+        *off = 16 << (depth - 8);
+        *y_rng = 219 << (depth - 8);
+        *uv_rng = 224 << (depth - 8);
+        break;
+    case AVCOL_RANGE_JPEG:
+        *off = 0;
+        *y_rng = *uv_rng = (256 << (depth - 8)) - 1;
+        break;
+    default:
+        return AVERROR(EINVAL);
+    }
+
+    return 0;
+}
+
+void ff_get_yuv_coeffs(int16_t out[3][3][8], double (*table)[3],
+                       int depth, int y_rng, int uv_rng, int yuv2rgb)
+{
+#define N (yuv2rgb ? m : n)
+#define M (yuv2rgb ? n : m)
+    int rng, n, m, o;
+    int bits = 1 << (yuv2rgb ? (depth - 1) : (29 - depth));
+    for (rng = y_rng, n = 0; n < 3; n++, rng = uv_rng) {
+        for (m = 0; m < 3; m++) {
+            out[N][M][0] = lrint(bits * (yuv2rgb ? 28672 : rng) * table[N][M] / (yuv2rgb ? rng : 28672));
+            for (o = 1; o < 8; o++)
+                out[N][M][o] = out[N][M][0];
+        }
+    }
+
+    if (yuv2rgb) {
+        av_assert2(out[0][1][0] == 0);
+        av_assert2(out[2][2][0] == 0);
+        av_assert2(out[0][0][0] == out[1][0][0]);
+        av_assert2(out[0][0][0] == out[2][0][0]);
+    } else {
+        av_assert2(out[1][2][0] == out[2][0][0]);
+    }
+}
+
 double ff_determine_signal_peak(AVFrame *in)
 {
     AVFrameSideData *sd = av_frame_get_side_data(in, AV_FRAME_DATA_CONTENT_LIGHT_LEVEL);
diff -rupN ffmpeg-4.4.orig/libavfilter/colorspace.h ffmpeg-4.4/libavfilter/colorspace.h
--- ffmpeg-4.4.orig/libavfilter/colorspace.h	2021-07-17 18:49:01.404571138 +0200
+++ ffmpeg-4.4/libavfilter/colorspace.h	2021-07-17 18:58:12.324142472 +0200
@@ -45,8 +45,13 @@ void ff_fill_rgb2xyz_table(const struct
                            double rgb2xyz[3][3]);
 
 const struct LumaCoefficients *ff_get_luma_coefficients(enum AVColorSpace csp);
+const struct PrimaryCoefficients *ff_get_color_primaries(enum AVColorPrimaries prm);
 void ff_fill_rgb2yuv_table(const struct LumaCoefficients *coeffs,
                            double rgb2yuv[3][3]);
+int ff_get_range_off(int *off, int *y_rng, int *uv_rng,
+                     enum AVColorRange rng, int depth);
+void ff_get_yuv_coeffs(int16_t out[3][3][8], double (*table)[3],
+                       int depth, int y_rng, int uv_rng, int yuv2rgb);
 
 double ff_determine_signal_peak(AVFrame *in);
 void ff_update_hdr_metadata(AVFrame *in, double peak);
diff -rupN ffmpeg-4.4.orig/libavfilter/cuda/cl_compat.h ffmpeg-4.4/libavfilter/cuda/cl_compat.h
--- ffmpeg-4.4.orig/libavfilter/cuda/cl_compat.h	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/cuda/cl_compat.h	2021-07-17 18:58:37.790943745 +0200
@@ -0,0 +1,22 @@
+/*
+ * OpenCL-to-CUDA compatibility header
+ *
+ * Copyright (c) 2020 rcombs
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
diff -rupN ffmpeg-4.4.orig/libavfilter/cuda/colorspace_common.h ffmpeg-4.4/libavfilter/cuda/colorspace_common.h
--- ffmpeg-4.4.orig/libavfilter/cuda/colorspace_common.h	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/cuda/colorspace_common.h	2021-07-17 19:00:20.851488473 +0200
@@ -0,0 +1,230 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFILTER_CUDA_COLORSPACE_COMMON_H
+#define AVFILTER_CUDA_COLORSPACE_COMMON_H
+
+#include "util.h"
+#include "libavutil/pixfmt.h"
+
+#define ST2084_MAX_LUMINANCE 10000.0f
+#define REFERENCE_WHITE 100.0f
+
+#define ST2084_M1 0.1593017578125f
+#define ST2084_M2 78.84375f
+#define ST2084_C1 0.8359375f
+#define ST2084_C2 18.8515625f
+#define ST2084_C3 18.6875f
+#define SDR_AVG   0.25f
+
+extern const float3 luma_src, luma_dst;
+extern const enum AVColorTransferCharacteristic trc_src, trc_dst;
+extern const enum AVColorRange range_src, range_dst;
+extern const enum AVChromaLocation chroma_loc_src, chroma_loc_dst;
+extern const bool rgb2rgb_passthrough;
+extern const float rgb2rgb_matrix[9];
+extern const float yuv_matrix[9], rgb_matrix[9];
+
+static __inline__ __device__ float get_luma_dst(float3 c, const float3& luma_dst) {
+    return luma_dst.x * c.x + luma_dst.y * c.y + luma_dst.z * c.z;
+}
+
+static __inline__ __device__ float get_luma_src(float3 c, const float3& luma_src) {
+    return luma_src.x * c.x + luma_src.y * c.y + luma_src.z * c.z;
+}
+
+static __inline__ __device__ float3 get_chroma_sample(float3 a, float3 b, float3 c, float3 d) {
+    switch (chroma_loc_dst) {
+    case AVCHROMA_LOC_LEFT:
+        return ((a) + (c)) * 0.5f;
+    case AVCHROMA_LOC_CENTER:
+    case AVCHROMA_LOC_UNSPECIFIED:
+    default:
+        return ((a) + (b) + (c) + (d)) * 0.25f;
+    case AVCHROMA_LOC_TOPLEFT:
+        return a;
+    case AVCHROMA_LOC_TOP:
+        return ((a) + (b)) * 0.5f;
+    case AVCHROMA_LOC_BOTTOMLEFT:
+        return c;
+    case AVCHROMA_LOC_BOTTOM:
+        return ((c) + (d)) * 0.5f;
+    }
+}
+
+static __inline__ __device__ float eotf_st2084(float x) {
+    float p = __powf(x, 1.0f / ST2084_M2);
+    float a = max(p -ST2084_C1, 0.0f);
+    float b = max(ST2084_C2 - ST2084_C3 * p, 1e-6f);
+    float c  = __powf(a / b, 1.0f / ST2084_M1);
+    return x > 0.0f ? c * ST2084_MAX_LUMINANCE / REFERENCE_WHITE : 0.0f;
+}
+
+static __inline__ __device__ float inverse_eotf_st2084(float x) {
+    float a = x;
+    x *= REFERENCE_WHITE / ST2084_MAX_LUMINANCE;
+    x = __powf(x, ST2084_M1);
+    x = (ST2084_C1 + ST2084_C2 * x) / (1.0f + ST2084_C3 * x);
+    return a > 0.0f ? __powf(x, ST2084_M2) : 0.0f;
+}
+
+#define HLG_A 0.17883277f
+#define HLG_B 0.28466892f
+#define HLG_C 0.55991073f
+
+// linearizer for HLG
+static __inline__ __device__ float inverse_oetf_hlg(float x) {
+    float a = 4.0f * x * x;
+    float b = __expf((x - HLG_C) / HLG_A) + HLG_B;
+    return x < 0.5f ? a : b;
+}
+
+// delinearizer for HLG
+static __inline__ __device__ float oetf_hlg(float x) {
+    float a = 0.5f * __sqrtf(x);
+    float b = HLG_A * __logf(x - HLG_B) + HLG_C;
+    return x <= 1.0f ? a : b;
+}
+
+static __inline__ __device__ float3 ootf_hlg(float3 c, float peak) {
+    float luma = get_luma_src(c, luma_src);
+    float gamma =  1.2f + 0.42f * __log10f(peak * REFERENCE_WHITE / 1000.0f);
+    gamma = max(1.0f, gamma);
+    float factor = peak * __powf(luma, gamma - 1.0f) / __powf(12.0f, gamma);
+    return c * factor;
+}
+
+static __inline__ __device__ float3 inverse_ootf_hlg(float3 c, float peak) {
+    float gamma = 1.2f + 0.42f * __log10f(peak * REFERENCE_WHITE / 1000.0f);
+    c = c * __powf(12.0f, gamma) / peak;
+    c = c / __powf(get_luma_dst(c, luma_dst), (gamma - 1.0f) / gamma);
+    return c;
+}
+
+static __inline__ __device__ float inverse_eotf_bt1886(float c) {
+    return c < 0.0f ? 0.0f : __powf(c, 1.0f / 2.4f);
+}
+
+static __inline__ __device__ float oetf_bt709(float c) {
+    c = c < 0.0f ? 0.0f : c;
+    float r1 = 4.5f * c;
+    float r2 = 1.099f * __powf(c, 0.45f) - 0.099f;
+    return c < 0.018f ? r1 : r2;
+}
+static __inline__ __device__ float inverse_oetf_bt709(float c) {
+    float r1 = c / 4.5f;
+    float r2 = __powf((c + 0.099f) / 1.099f, 1.0f / 0.45f);
+    return c < 0.081f ? r1 : r2;
+}
+
+static __inline__ __device__ float3 ootf(float3 c, float peak)
+{
+    if (trc_src == AVCOL_TRC_ARIB_STD_B67)
+        return ootf_hlg(c, peak);
+    else
+        return c;
+}
+
+static __inline__ __device__ float3 inverse_ootf(float3 c, float peak)
+{
+    if (trc_dst == AVCOL_TRC_ARIB_STD_B67)
+        return inverse_ootf_hlg(c, peak);
+    else
+        return c;
+}
+
+static __inline__ __device__ float linearize(float x)
+{
+    if (trc_src == AVCOL_TRC_SMPTE2084)
+        return eotf_st2084(x);
+    else if (trc_src == AVCOL_TRC_ARIB_STD_B67)
+        return inverse_oetf_hlg(x);
+    else
+        return x;
+}
+
+static __inline__ __device__ float delinearize(float x)
+{
+    if (trc_dst == AVCOL_TRC_BT709 || trc_dst == AVCOL_TRC_BT2020_10)
+        return inverse_eotf_bt1886(x);
+    else
+        return x;
+}
+
+static __inline__ __device__ float3 yuv2rgb(float y, float u, float v) {
+    if (range_src == AVCOL_RANGE_JPEG) {
+        u -= 0.5f; v -= 0.5f;
+    } else {
+        y = (y * 255.0f -  16.0f) / 219.0f;
+        u = (u * 255.0f - 128.0f) / 224.0f;
+        v = (v * 255.0f - 128.0f) / 224.0f;
+    }
+    float r = y * rgb_matrix[0] + u * rgb_matrix[1] + v * rgb_matrix[2];
+    float g = y * rgb_matrix[3] + u * rgb_matrix[4] + v * rgb_matrix[5];
+    float b = y * rgb_matrix[6] + u * rgb_matrix[7] + v * rgb_matrix[8];
+    return make_float3(r, g, b);
+}
+
+static __inline__ __device__ float3 yuv2lrgb(float3 yuv) {
+    float3 rgb = yuv2rgb(yuv.x, yuv.y, yuv.z);
+    return make_float3(linearize(rgb.x),
+                       linearize(rgb.y),
+                       linearize(rgb.z));
+}
+
+static __inline__ __device__ float3 rgb2yuv(float r, float g, float b) {
+    float y = r*yuv_matrix[0] + g*yuv_matrix[1] + b*yuv_matrix[2];
+    float u = r*yuv_matrix[3] + g*yuv_matrix[4] + b*yuv_matrix[5];
+    float v = r*yuv_matrix[6] + g*yuv_matrix[7] + b*yuv_matrix[8];
+    if (range_dst == AVCOL_RANGE_JPEG) {
+        u += 0.5f; v += 0.5f;
+    } else {
+        y = (219.0f * y + 16.0f) / 255.0f;
+        u = (224.0f * u + 128.0f) / 255.0f;
+        v = (224.0f * v + 128.0f) / 255.0f;
+    }
+    return make_float3(y, u, v);
+}
+
+static __inline__ __device__ float rgb2y(float r, float g, float b) {
+    float y = r*yuv_matrix[0] + g*yuv_matrix[1] + b*yuv_matrix[2];
+    if (range_dst != AVCOL_RANGE_JPEG)
+        y = (219.0f * y + 16.0f) / 255.0f;
+    return y;
+}
+
+static __inline__ __device__ float3 lrgb2yuv(float3 c) {
+    float r = delinearize(c.x);
+    float g = delinearize(c.y);
+    float b = delinearize(c.z);
+    return rgb2yuv(r, g, b);
+}
+
+static __inline__ __device__ float3 lrgb2lrgb(float3 c) {
+    if (rgb2rgb_passthrough) {
+        return c;
+    } else {
+        float r = c.x, g = c.y, b = c.z;
+        float rr = rgb2rgb_matrix[0] * r + rgb2rgb_matrix[1] * g + rgb2rgb_matrix[2] * b;
+        float gg = rgb2rgb_matrix[3] * r + rgb2rgb_matrix[4] * g + rgb2rgb_matrix[5] * b;
+        float bb = rgb2rgb_matrix[6] * r + rgb2rgb_matrix[7] * g + rgb2rgb_matrix[8] * b;
+        return make_float3(rr, gg, bb);
+    }
+}
+
+#endif /* AVFILTER_CUDA_COLORSPACE_COMMON_H */
diff -rupN ffmpeg-4.4.orig/libavfilter/cuda/host_util.c ffmpeg-4.4/libavfilter/cuda/host_util.c
--- ffmpeg-4.4.orig/libavfilter/cuda/host_util.c	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/cuda/host_util.c	2021-07-17 19:00:56.315009248 +0200
@@ -0,0 +1,37 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavfilter/colorspace.h"
+#include "host_util.h"
+
+int ff_make_cuda_frame(FFCUDAFrame *dst, const AVFrame *src)
+{
+    int i = 0;
+    for (i = 0; i < 4; i++) {
+        dst->data[i] = src->data[i];
+        dst->linesize[i] = src->linesize[i];
+    }
+
+    dst->width  = src->width;
+    dst->height = src->height;
+
+    dst->peak = ff_determine_signal_peak(src);
+    dst->avg  = 0.f; //FIXME
+
+    return 0;
+}
diff -rupN ffmpeg-4.4.orig/libavfilter/cuda/host_util.h ffmpeg-4.4/libavfilter/cuda/host_util.h
--- ffmpeg-4.4.orig/libavfilter/cuda/host_util.h	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/cuda/host_util.h	2021-07-17 19:01:21.595142865 +0200
@@ -0,0 +1,28 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFILTER_CUDA_HOST_UTIL_H
+#define AVFILTER_CUDA_HOST_UTIL_H
+
+#include "libavutil/frame.h"
+
+#include "shared.h"
+
+int ff_make_cuda_frame(FFCUDAFrame *dst, const AVFrame *src);
+
+#endif /* AVFILTER_CUDA_HOST_UTIL_H */
diff -rupN ffmpeg-4.4.orig/libavfilter/cuda/pixfmt.h ffmpeg-4.4/libavfilter/cuda/pixfmt.h
--- ffmpeg-4.4.orig/libavfilter/cuda/pixfmt.h	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/cuda/pixfmt.h	2021-07-17 19:02:38.468882513 +0200
@@ -0,0 +1,209 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFILTER_CUDA_PIXFMT_H
+#define AVFILTER_CUDA_PIXFMT_H
+
+#include "shared.h"
+
+extern const enum AVPixelFormat fmt_src, fmt_dst;
+extern const int depth_src, depth_dst;
+
+// Single-sample read function
+template<class T, int p>
+static __inline__ __device__ T read_sample(const FFCUDAFrame& frame, int x, int y)
+{
+    T* ptr = (T*)(frame.data[p] + (y * frame.linesize[p]));
+    return ptr[x];
+}
+
+// Per-format read functions
+static __inline__ __device__ ushort3 read_p016(const FFCUDAFrame& frame, int x, int y)
+{
+    return make_ushort3(read_sample<unsigned short, 0>(frame, x,          y),
+                        read_sample<unsigned short, 1>(frame, (x & ~1),     y / 2),
+                        read_sample<unsigned short, 1>(frame, (x & ~1) + 1, y / 2));
+}
+
+static __inline__ __device__ ushort3 read_p010(const FFCUDAFrame& frame, int x, int y)
+{
+    ushort3 val = read_p016(frame, x, y);
+    return make_ushort3(val.x >> 6,
+                        val.y >> 6,
+                        val.z >> 6);
+}
+
+static __inline__ __device__ ushort3 read_yuv420p16(const FFCUDAFrame& frame, int x, int y)
+{
+    return make_ushort3(read_sample<unsigned short, 0>(frame, x,      y),
+                        read_sample<unsigned short, 1>(frame, x / 2, y / 2),
+                        read_sample<unsigned short, 2>(frame, x / 2, y / 2));
+}
+
+static __inline__ __device__ ushort3 read_yuv420p10(const FFCUDAFrame& frame, int x, int y)
+{
+    ushort3 val = read_yuv420p16(frame, x, y);
+    return make_ushort3(val.x >> 6,
+                        val.y >> 6,
+                        val.z >> 6);
+}
+
+// Generic read functions
+static __inline__ __device__ ushort3 read_px(const FFCUDAFrame& frame, int x, int y)
+{
+    if (fmt_src == AV_PIX_FMT_P016)
+        return read_p016(frame, x, y);
+    else if (fmt_src == AV_PIX_FMT_P010)
+        return read_p010(frame, x, y);
+    else
+        return make_ushort3(0, 0, 0);
+}
+
+static __inline__ __device__ float sample_to_float(unsigned short i)
+{
+    return (float)i / ((1 << depth_src) - 1);
+}
+
+static __inline__ __device__ float3 pixel_to_float3(ushort3 flt)
+{
+    return make_float3(sample_to_float(flt.x),
+                       sample_to_float(flt.y),
+                       sample_to_float(flt.z));
+}
+
+static __inline__ __device__ float3 read_px_flt(const FFCUDAFrame& frame, int x, int y)
+{
+    return pixel_to_float3(read_px(frame, x, y));
+}
+
+// Single-sample write function
+template<int p, class T>
+static __inline__ __device__ void write_sample(const FFCUDAFrame& frame, int x, int y, T sample)
+{
+    T* ptr = (T*)(frame.data[p] + (y * frame.linesize[p]));
+    ptr[x] = sample;
+}
+
+// Per-format write functions
+static __inline__ __device__ void write_nv12_2x2(const FFCUDAFrame& frame, int x, int y, ushort3 a, ushort3 b, ushort3 c, ushort3 d, ushort3 chroma)
+{
+    write_sample<0>(frame, x,     y,     (unsigned char)a.x);
+    write_sample<0>(frame, x + 1, y,     (unsigned char)b.x);
+    write_sample<0>(frame, x,     y + 1, (unsigned char)c.x);
+    write_sample<0>(frame, x + 1, y + 1, (unsigned char)d.x);
+
+    write_sample<1>(frame, (x & ~1),     y / 2, (unsigned char)chroma.y);
+    write_sample<1>(frame, (x & ~1) + 1, y / 2, (unsigned char)chroma.z);
+}
+
+static __inline__ __device__ void write_yuv420p_2x2(const FFCUDAFrame& frame, int x, int y, ushort3 a, ushort3 b, ushort3 c, ushort3 d, ushort3 chroma)
+{
+    write_sample<0>(frame, x,     y,     (unsigned char)a.x);
+    write_sample<0>(frame, x + 1, y,     (unsigned char)b.x);
+    write_sample<0>(frame, x,     y + 1, (unsigned char)c.x);
+    write_sample<0>(frame, x + 1, y + 1, (unsigned char)d.x);
+
+    write_sample<1>(frame, x / 2, y / 2, (unsigned char)chroma.y);
+    write_sample<2>(frame, x / 2, y / 2, (unsigned char)chroma.z);
+}
+
+static __inline__ __device__ void write_p016_2x2(const FFCUDAFrame& frame, int x, int y, ushort3 a, ushort3 b, ushort3 c, ushort3 d, ushort3 chroma)
+{
+    write_sample<0>(frame, x,     y,     (unsigned short)a.x);
+    write_sample<0>(frame, x + 1, y,     (unsigned short)b.x);
+    write_sample<0>(frame, x,     y + 1, (unsigned short)c.x);
+    write_sample<0>(frame, x + 1, y + 1, (unsigned short)d.x);
+
+    write_sample<1>(frame, (x & ~1),     y / 2, (unsigned short)chroma.y);
+    write_sample<1>(frame, (x & ~1) + 1, y / 2, (unsigned short)chroma.z);
+}
+
+static __inline__ __device__ void write_p010_2x2(const FFCUDAFrame& frame, int x, int y, ushort3 a, ushort3 b, ushort3 c, ushort3 d, ushort3 chroma)
+{
+    write_sample<0>(frame, x,     y,     (unsigned short)(a.x << 6));
+    write_sample<0>(frame, x + 1, y,     (unsigned short)(b.x << 6));
+    write_sample<0>(frame, x,     y + 1, (unsigned short)(c.x << 6));
+    write_sample<0>(frame, x + 1, y + 1, (unsigned short)(d.x << 6));
+
+    write_sample<1>(frame, (x & ~1),     y / 2, (unsigned short)(chroma.y << 6));
+    write_sample<1>(frame, (x & ~1) + 1, y / 2, (unsigned short)(chroma.z << 6));
+}
+
+static __inline__ __device__ void write_yuv420p16_2x2(const FFCUDAFrame& frame, int x, int y, ushort3 a, ushort3 b, ushort3 c, ushort3 d, ushort3 chroma)
+{
+    write_sample<0>(frame, x,     y,     (unsigned short)a.x);
+    write_sample<0>(frame, x + 1, y,     (unsigned short)b.x);
+    write_sample<0>(frame, x,     y + 1, (unsigned short)c.x);
+    write_sample<0>(frame, x + 1, y + 1, (unsigned short)d.x);
+
+    write_sample<1>(frame, x / 2, y / 2, (unsigned short)chroma.y);
+    write_sample<2>(frame, x / 2, y / 2, (unsigned short)chroma.z);
+}
+
+static __inline__ __device__ void write_yuv420p10_2x2(const FFCUDAFrame& frame, int x, int y, ushort3 a, ushort3 b, ushort3 c, ushort3 d, ushort3 chroma)
+{
+    write_sample<0>(frame, x,     y,     (unsigned short)(a.x << 6));
+    write_sample<0>(frame, x + 1, y,     (unsigned short)(b.x << 6));
+    write_sample<0>(frame, x,     y + 1, (unsigned short)(c.x << 6));
+    write_sample<0>(frame, x + 1, y + 1, (unsigned short)(d.x << 6));
+
+    write_sample<1>(frame, x / 2, y / 2, (unsigned short)(chroma.y << 6));
+    write_sample<2>(frame, x / 2, y / 2, (unsigned short)(chroma.z << 6));
+}
+
+// Generic write functions
+static __inline__ __device__ void write_2x2(const FFCUDAFrame& frame, int x, int y, ushort3 a, ushort3 b, ushort3 c, ushort3 d, ushort3 chroma)
+{
+    if (fmt_dst == AV_PIX_FMT_YUV420P)
+        write_yuv420p_2x2(frame, x, y, a, b, c, d, chroma);
+    else if (fmt_dst == AV_PIX_FMT_NV12)
+        write_nv12_2x2(frame, x, y, a, b, c, d, chroma);
+    else if (fmt_dst == AV_PIX_FMT_P016)
+        write_p016_2x2(frame, x, y, a, b, c, d, chroma);
+    else if (fmt_dst == AV_PIX_FMT_P010)
+        write_p010_2x2(frame, x, y, a, b, c, d, chroma);
+}
+
+static __inline__ __device__ unsigned short sample_to_ushort(float flt)
+{
+    return (unsigned short)(flt * ((1 << depth_dst) - 1));
+}
+
+static __inline__ __device__ ushort3 pixel_to_ushort3(float3 flt)
+{
+    return make_ushort3(sample_to_ushort(flt.x),
+                        sample_to_ushort(flt.y),
+                        sample_to_ushort(flt.z));
+}
+
+static __inline__ __device__ void write_2x2_flt(const FFCUDAFrame& frame, int x, int y, float3 a, float3 b, float3 c, float3 d)
+{
+    float3 chroma = get_chroma_sample(a, b, c, d);
+
+    ushort3 ia = pixel_to_ushort3(a);
+    ushort3 ib = pixel_to_ushort3(b);
+    ushort3 ic = pixel_to_ushort3(c);
+    ushort3 id = pixel_to_ushort3(d);
+
+    ushort3 ichroma = pixel_to_ushort3(chroma);
+
+    write_2x2(frame, x, y, ia, ib, ic, id, ichroma);
+}
+
+#endif /* AVFILTER_CUDA_PIXFMT_H */
+
diff -rupN ffmpeg-4.4.orig/libavfilter/cuda/shared.h ffmpeg-4.4/libavfilter/cuda/shared.h
--- ffmpeg-4.4.orig/libavfilter/cuda/shared.h	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/cuda/shared.h	2021-07-17 19:03:24.572459526 +0200
@@ -0,0 +1,32 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFILTER_CUDA_SHARED_H
+#define AVFILTER_CUDA_SHARED_H
+
+typedef struct FFCUDAFrame {
+    unsigned char *data[4];
+    int linesize[4];
+
+    int width, height;
+
+    float peak, avg;
+} FFCUDAFrame;
+
+#endif /* AVFILTER_CUDA_SHARED_H */
+
diff -rupN ffmpeg-4.4.orig/libavfilter/cuda/tonemap.cu ffmpeg-4.4/libavfilter/cuda/tonemap.cu
--- ffmpeg-4.4.orig/libavfilter/cuda/tonemap.cu	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/cuda/tonemap.cu	2021-07-17 19:04:40.412861473 +0200
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2020 rcombs
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "colorspace_common.h"
+#include "pixfmt.h"
+#include "tonemap.h"
+#include "util.h"
+
+extern const enum TonemapAlgorithm tonemap_func;
+extern const float tone_param;
+extern const float desat_param;
+
+#define mix(x, y, a) ((x) + ((y) - (x)) * (a))
+
+static __inline__ __device__
+float hable_f(float in) {
+    float a = 0.15f, b = 0.50f, c = 0.10f, d = 0.20f, e = 0.02f, f = 0.30f;
+    return (in * (in * a + b * c) + d * e) / (in * (in * a + b) + d * f) - e / f;
+}
+
+static __inline__ __device__
+float direct(float s, float peak) {
+    return s;
+}
+
+static __inline__ __device__
+float linear(float s, float peak) {
+    return s * tone_param / peak;
+}
+
+static __inline__ __device__
+float gamma(float s, float peak) {
+    float p = s > 0.05f ? s / peak : 0.05f / peak;
+    float v = __powf(p, 1.0f / tone_param);
+    return s > 0.05f ? v : (s * v /0.05f);
+}
+
+static __inline__ __device__
+float clip(float s, float peak) {
+    return clamp(s * tone_param, 0.0f, 1.0f);
+}
+
+static __inline__ __device__
+float reinhard(float s, float peak) {
+    return s / (s + tone_param) * (peak + tone_param) / peak;
+}
+
+static __inline__ __device__
+float hable(float s, float peak) {
+    return hable_f(s) / hable_f(peak);
+}
+
+static __inline__ __device__
+float mobius(float s, float peak) {
+    float j = tone_param;
+    float a, b;
+
+    if (s <= j)
+        return s;
+
+    a = -j * j * (peak - 1.0f) / (j * j - 2.0f * j + peak);
+    b = (j * j - 2.0f * j * peak + peak) / max(peak - 1.0f, 1e-6f);
+
+    return (b * b + 2.0f * b * j + j * j) / (b - a) * (s + a) / (s + b);
+}
+
+static __inline__ __device__
+float bt2390(float s, float peak, float dst_peak) {
+    float peak_pq = inverse_eotf_st2084(peak);
+    float scale = 1.0f / peak_pq;
+
+    float s_pq = inverse_eotf_st2084(s) * scale;
+    float maxLum = inverse_eotf_st2084(dst_peak) * scale;
+
+    float ks = 1.5f * maxLum - 0.5f;
+    float tb = (s_pq - ks) / (1.0f - ks);
+    float tb2 = tb * tb;
+    float tb3 = tb2 * tb;
+    float pb = (2.0f * tb3 - 3.0f * tb2 + 1.0f) * ks +
+               (tb3 - 2.0f * tb2 + tb) * (1.0f - ks) +
+               (-2.0f * tb3 + 3.0f * tb2) * maxLum;
+    float sig = (s_pq < ks) ? s_pq : pb;
+
+    return eotf_st2084(sig * peak_pq);
+}
+
+static __inline__ __device__
+float map(float s, float peak, float dst_peak)
+{
+    switch (tonemap_func) {
+    case TONEMAP_NONE:
+    default:
+        return direct(s, peak);
+    case TONEMAP_LINEAR:
+        return linear(s, peak);
+    case TONEMAP_GAMMA:
+        return gamma(s, peak);
+    case TONEMAP_CLIP:
+        return clip(s, peak);
+    case TONEMAP_REINHARD:
+        return reinhard(s, peak);
+    case TONEMAP_HABLE:
+        return hable(s, peak);
+    case TONEMAP_MOBIUS:
+        return mobius(s, peak);
+    case TONEMAP_BT2390:
+        return bt2390(s, peak, dst_peak);
+    }
+}
+
+static __inline__ __device__
+float3 map_one_pixel_rgb(float3 rgb, const FFCUDAFrame& src, const FFCUDAFrame& dst) {
+    float sig = max(max(rgb.x, max(rgb.y, rgb.z)), 1e-6f);
+    float peak = src.peak;
+    float dst_peak = dst.peak;
+
+    // Rescale the variables in order to bring it into a representation where
+    // 1.0 represents the dst_peak. This is because all of the tone mapping
+    // algorithms are defined in such a way that they map to the range [0.0, 1.0].
+    if (dst.peak > 1.0f) {
+        sig *= 1.0f / dst.peak;
+        peak *= 1.0f / dst.peak;
+    }
+
+    float sig_old = sig;
+
+    /*
+    // Scale the signal to compensate for differences in the average brightness
+    float slope = min(1.0f, dst.average / src.average);
+    sig *= slope;
+    peak *= slope;
+    */
+
+    // Desaturate the color using a coefficient dependent on the signal level
+    if (desat_param > 0.0f) {
+        float luma = get_luma_dst(rgb, luma_dst);
+        float coeff = max(sig - 0.18f, 1e-6f) / max(sig, 1e-6f);
+        coeff = __powf(coeff, 10.0f / desat_param);
+        rgb = mix(rgb, make_float3(luma, luma, luma), make_float3(coeff, coeff, coeff));
+        /*
+        sig = mix(sig, luma * slope, coeff);
+        */
+    }
+
+    sig = map(sig, peak, dst_peak);
+
+    sig = min(sig, 1.0f);
+    rgb = rgb * (sig/sig_old);
+    return rgb;
+}
+
+// map from source space YUV to destination space RGB
+static __inline__ __device__
+float3 map_to_dst_space_from_yuv(float3 yuv, float peak) {
+    float3 c = yuv2lrgb(yuv);
+    c = ootf(c, peak);
+    c = lrgb2lrgb(c);
+    return c;
+}
+
+
+extern "C" {
+
+__global__ void tonemap(FFCUDAFrame src, FFCUDAFrame dst)
+{
+    int xi = blockIdx.x * blockDim.x + threadIdx.x;
+    int yi = blockIdx.y * blockDim.y + threadIdx.y;
+    // each work item process four pixels
+    int x = 2 * xi;
+    int y = 2 * yi;
+
+    if (y + 1 < src.height && x + 1 < src.width)
+    {
+        float3 yuv0 = read_px_flt(src, x,     y);
+        float3 yuv1 = read_px_flt(src, x + 1, y);
+        float3 yuv2 = read_px_flt(src, x,     y + 1);
+        float3 yuv3 = read_px_flt(src, x + 1, y + 1);
+
+        float3 c0 = map_to_dst_space_from_yuv(yuv0, src.peak);
+        float3 c1 = map_to_dst_space_from_yuv(yuv1, src.peak);
+        float3 c2 = map_to_dst_space_from_yuv(yuv2, src.peak);
+        float3 c3 = map_to_dst_space_from_yuv(yuv3, src.peak);
+
+        c0 = map_one_pixel_rgb(c0, src, dst);
+        c1 = map_one_pixel_rgb(c1, src, dst);
+        c2 = map_one_pixel_rgb(c2, src, dst);
+        c3 = map_one_pixel_rgb(c3, src, dst);
+
+        c0 = inverse_ootf(c0, dst.peak);
+        c1 = inverse_ootf(c1, dst.peak);
+        c2 = inverse_ootf(c2, dst.peak);
+        c3 = inverse_ootf(c3, dst.peak);
+
+        yuv0 = lrgb2yuv(c0);
+        yuv1 = lrgb2yuv(c1);
+        yuv2 = lrgb2yuv(c2);
+        yuv3 = lrgb2yuv(c3);
+
+        write_2x2_flt(dst, x, y, yuv0, yuv1, yuv2, yuv3);
+    }
+}
+
+}
+
diff -rupN ffmpeg-4.4.orig/libavfilter/cuda/tonemap.h ffmpeg-4.4/libavfilter/cuda/tonemap.h
--- ffmpeg-4.4.orig/libavfilter/cuda/tonemap.h	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/cuda/tonemap.h	2021-07-17 19:05:04.322988208 +0200
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2020 rcombs
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef AVFILTER_CUDA_TONEMAP_H
+#define AVFILTER_CUDA_TONEMAP_H
+
+enum TonemapAlgorithm {
+    TONEMAP_NONE,
+    TONEMAP_LINEAR,
+    TONEMAP_GAMMA,
+    TONEMAP_CLIP,
+    TONEMAP_REINHARD,
+    TONEMAP_HABLE,
+    TONEMAP_MOBIUS,
+    TONEMAP_BT2390,
+    TONEMAP_MAX,
+};
+
+#endif /* AVFILTER_CUDA_TONEMAP_H */
+
diff -rupN ffmpeg-4.4.orig/libavfilter/cuda/util.h ffmpeg-4.4/libavfilter/cuda/util.h
--- ffmpeg-4.4.orig/libavfilter/cuda/util.h	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/cuda/util.h	2021-07-17 19:05:35.556487096 +0200
@@ -0,0 +1,55 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFILTER_CUDA_UTIL_H
+#define AVFILTER_CUDA_UTIL_H
+
+static inline __device__ float3 operator+(const float3 &a, const float3 &b) {
+    return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
+}
+
+static inline __device__ float3 operator+(const float3 &a, float b) {
+    return make_float3(a.x + b, a.y + b, a.z + b);
+}
+
+static inline __device__ float3 operator-(const float3 &a, const float3 &b) {
+    return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
+}
+
+static inline __device__ float3 operator-(const float3 &a, float b) {
+    return make_float3(a.x - b, a.y - b, a.z - b);
+}
+
+static inline __device__ float3 operator*(const float3 &a, const float3 &b) {
+    return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
+}
+
+static inline __device__ float3 operator*(const float3 &a, float b) {
+    return make_float3(a.x * b, a.y * b, a.z * b);
+}
+
+static inline __device__ float3 operator/(const float3 &a, const float3 &b) {
+    return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
+}
+
+static inline __device__ float3 operator/(const float3 &a, float b) {
+    return make_float3(a.x / b, a.y / b, a.z / b);
+}
+
+#endif /* AVFILTER_CUDA_UTIL_H */
+
diff -rupN ffmpeg-4.4.orig/libavfilter/Makefile ffmpeg-4.4/libavfilter/Makefile
--- ffmpeg-4.4.orig/libavfilter/Makefile	2021-07-17 18:49:01.404571138 +0200
+++ ffmpeg-4.4/libavfilter/Makefile	2021-07-17 18:55:06.099824850 +0200
@@ -449,6 +449,8 @@ OBJS-$(CONFIG_TMEDIAN_FILTER)
 OBJS-$(CONFIG_TMIDEQUALIZER_FILTER)          += vf_tmidequalizer.o
 OBJS-$(CONFIG_TMIX_FILTER)                   += vf_mix.o framesync.o
 OBJS-$(CONFIG_TONEMAP_FILTER)                += vf_tonemap.o colorspace.o
+OBJS-$(CONFIG_TONEMAP_CUDA_FILTER)           += vf_tonemap_cuda.o cuda/tonemap.ptx.o \
+                                                cuda/host_util.o
 OBJS-$(CONFIG_TONEMAP_OPENCL_FILTER)         += vf_tonemap_opencl.o colorspace.o opencl.o \
                                                 opencl/tonemap.o opencl/colorspace_common.o
 OBJS-$(CONFIG_TONEMAP_VAAPI_FILTER)          += vf_tonemap_vaapi.o vaapi_vpp.o
diff -rupN ffmpeg-4.4.orig/libavfilter/vf_tonemap_cuda.c ffmpeg-4.4/libavfilter/vf_tonemap_cuda.c
--- ffmpeg-4.4.orig/libavfilter/vf_tonemap_cuda.c	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-4.4/libavfilter/vf_tonemap_cuda.c	2021-07-17 19:08:58.307561780 +0200
@@ -0,0 +1,627 @@
+/*
+* Copyright (c) 2017, NVIDIA CORPORATION. All rights reserved.
+* Copyright (c) 2020 rcombs
+*
+* This file is part of FFmpeg.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a
+* copy of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+* DEALINGS IN THE SOFTWARE.
+*/
+
+#include <float.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "libavutil/avassert.h"
+#include "libavutil/avstring.h"
+#include "libavutil/bprint.h"
+#include "libavutil/common.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_cuda_internal.h"
+#include "libavutil/cuda_check.h"
+#include "libavutil/internal.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+
+#include "avfilter.h"
+#include "colorspace.h"
+#include "cuda/host_util.h"
+#include "cuda/shared.h"
+#include "cuda/tonemap.h"
+#include "dither_matrix.h"
+#include "formats.h"
+#include "internal.h"
+#include "scale_eval.h"
+#include "video.h"
+
+static const enum AVPixelFormat supported_formats[] = {
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_NV12,
+    AV_PIX_FMT_P010,
+    AV_PIX_FMT_P016
+};
+
+#define DIV_UP(a, b) ( ((a) + (b) - 1) / (b) )
+#define ALIGN_UP(a, b) (((a) + (b) - 1) & ~((b) - 1))
+#define NUM_BUFFERS 2
+#define BLOCKX 32
+#define BLOCKY 16
+
+#define CHECK_CU(x) FF_CUDA_CHECK_DL(ctx, s->hwctx->internal->cuda_dl, x)
+
+typedef struct TonemapCUDAContext {
+    const AVClass *class;
+
+    AVCUDADeviceContext *hwctx;
+
+    enum AVPixelFormat in_fmt, out_fmt;
+
+    enum AVColorRange in_range, out_range;
+    enum AVColorTransferCharacteristic in_trc, out_trc;
+    enum AVColorSpace in_spc, out_spc;
+    enum AVColorPrimaries in_pri, out_pri;
+    enum AVChromaLocation in_chroma_loc, out_chroma_loc;
+
+    AVBufferRef *frames_ctx;
+    AVFrame     *frame;
+
+    AVFrame *tmp_frame;
+
+    /**
+     * Output sw format. AV_PIX_FMT_NONE for no conversion.
+     */
+    enum AVPixelFormat format;
+    char *format_str;
+
+    CUcontext   cu_ctx;
+    CUmodule    cu_module;
+
+    CUfunction  cu_func;
+
+    CUdeviceptr srcBuffer;
+    CUdeviceptr dstBuffer;
+
+    enum TonemapAlgorithm tonemap;
+    double param;
+    double desat_param;
+    double peak;
+    double scene_threshold;
+
+    const AVPixFmtDescriptor *in_desc, *out_desc;
+} TonemapCUDAContext;
+
+static av_cold int init(AVFilterContext *ctx)
+{
+    TonemapCUDAContext *s = ctx->priv;
+
+    if (!strcmp(s->format_str, "same")) {
+        s->format = AV_PIX_FMT_NONE;
+    } else {
+        s->format = av_get_pix_fmt(s->format_str);
+        if (s->format == AV_PIX_FMT_NONE) {
+            av_log(ctx, AV_LOG_ERROR, "Unrecognized pixel format: %s\n", s->format_str);
+            return AVERROR(EINVAL);
+        }
+    }
+
+    s->frame = av_frame_alloc();
+    if (!s->frame)
+        return AVERROR(ENOMEM);
+
+    s->tmp_frame = av_frame_alloc();
+    if (!s->tmp_frame)
+        return AVERROR(ENOMEM);
+
+    return 0;
+}
+
+static av_cold void uninit(AVFilterContext *ctx)
+{
+    TonemapCUDAContext *s = ctx->priv;
+
+    if (s->hwctx) {
+        CudaFunctions *cu = s->hwctx->internal->cuda_dl;
+        CUcontext dummy, cuda_ctx = s->hwctx->cuda_ctx;
+
+        CHECK_CU(cu->cuCtxPushCurrent(cuda_ctx));
+
+        if (s->cu_module) {
+            CHECK_CU(cu->cuModuleUnload(s->cu_module));
+            s->cu_func = NULL;
+            s->cu_module = NULL;
+        }
+
+        CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+    }
+
+    av_frame_free(&s->frame);
+    av_buffer_unref(&s->frames_ctx);
+    av_frame_free(&s->tmp_frame);
+}
+
+static int query_formats(AVFilterContext *ctx)
+{
+    static const enum AVPixelFormat pixel_formats[] = {
+        AV_PIX_FMT_CUDA, AV_PIX_FMT_NONE,
+    };
+    AVFilterFormats *pix_fmts = ff_make_format_list(pixel_formats);
+
+    return ff_set_common_formats(ctx, pix_fmts);
+}
+
+static av_cold int init_stage(TonemapCUDAContext *s, AVBufferRef *device_ctx,
+                              AVFilterLink *outlink)
+{
+    AVBufferRef *out_ref = NULL;
+    AVHWFramesContext *out_ctx;
+    int ret;
+
+    out_ref = av_hwframe_ctx_alloc(device_ctx);
+    if (!out_ref)
+        return AVERROR(ENOMEM);
+    out_ctx = (AVHWFramesContext*)out_ref->data;
+
+    out_ctx->format    = AV_PIX_FMT_CUDA;
+    out_ctx->sw_format = s->out_fmt;
+    out_ctx->width     = FFALIGN(outlink->w,  32);
+    out_ctx->height    = FFALIGN(outlink->h, 32);
+
+    ret = av_hwframe_ctx_init(out_ref);
+    if (ret < 0)
+        goto fail;
+
+    av_frame_unref(s->frame);
+    ret = av_hwframe_get_buffer(out_ref, s->frame, 0);
+    if (ret < 0)
+        goto fail;
+
+    s->frame->width  = outlink->w;
+    s->frame->height = outlink->h;
+
+    av_buffer_unref(&s->frames_ctx);
+    s->frames_ctx = out_ref;
+
+    return 0;
+fail:
+    av_buffer_unref(&out_ref);
+    return ret;
+}
+
+static int format_is_supported(enum AVPixelFormat fmt)
+{
+    int i;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++)
+        if (supported_formats[i] == fmt)
+            return 1;
+    return 0;
+}
+
+static av_cold int init_processing_chain(AVFilterContext *ctx, AVFilterLink *outlink)
+{
+    TonemapCUDAContext *s = ctx->priv;
+
+    AVHWFramesContext *in_frames_ctx;
+
+    enum AVPixelFormat in_format;
+    enum AVPixelFormat out_format;
+    int ret;
+
+    /* check that we have a hw context */
+    if (!ctx->inputs[0]->hw_frames_ctx) {
+        av_log(ctx, AV_LOG_ERROR, "No hw context provided on input\n");
+        return AVERROR(EINVAL);
+    }
+    in_frames_ctx = (AVHWFramesContext*)ctx->inputs[0]->hw_frames_ctx->data;
+    in_format     = in_frames_ctx->sw_format;
+    out_format    = (s->format == AV_PIX_FMT_NONE) ? in_format : s->format;
+
+    if (!format_is_supported(in_format)) {
+        av_log(ctx, AV_LOG_ERROR, "Unsupported input format: %s\n",
+               av_get_pix_fmt_name(in_format));
+        return AVERROR(ENOSYS);
+    }
+    if (!format_is_supported(out_format)) {
+        av_log(ctx, AV_LOG_ERROR, "Unsupported output format: %s\n",
+               av_get_pix_fmt_name(out_format));
+        return AVERROR(ENOSYS);
+    }
+
+    s->in_fmt = in_format;
+    s->out_fmt = out_format;
+
+    ret = init_stage(s, in_frames_ctx->device_ref, outlink);
+    if (ret < 0)
+        return ret;
+
+    ctx->outputs[0]->hw_frames_ctx = av_buffer_ref(s->frames_ctx);
+    if (!ctx->outputs[0]->hw_frames_ctx)
+        return AVERROR(ENOMEM);
+
+    return 0;
+}
+
+static const struct PrimaryCoefficients primaries_table[AVCOL_PRI_NB] = {
+    [AVCOL_PRI_BT709]  = { 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 },
+    [AVCOL_PRI_BT2020] = { 0.708, 0.292, 0.170, 0.797, 0.131, 0.046 },
+};
+
+static const struct WhitepointCoefficients whitepoint_table[AVCOL_PRI_NB] = {
+    [AVCOL_PRI_BT709]  = { 0.3127, 0.3290 },
+    [AVCOL_PRI_BT2020] = { 0.3127, 0.3290 },
+};
+
+static int get_rgb2rgb_matrix(enum AVColorPrimaries in, enum AVColorPrimaries out,
+                              double rgb2rgb[3][3]) {
+    double rgb2xyz[3][3], xyz2rgb[3][3];
+
+    ff_fill_rgb2xyz_table(&primaries_table[out], &whitepoint_table[out], rgb2xyz);
+    ff_matrix_invert_3x3(rgb2xyz, xyz2rgb);
+    ff_fill_rgb2xyz_table(&primaries_table[in], &whitepoint_table[in], rgb2xyz);
+    ff_matrix_mul_3x3(rgb2rgb, rgb2xyz, xyz2rgb);
+
+    return 0;
+}
+
+static av_cold int compile(AVFilterLink *inlink)
+{
+    int ret = 0;
+    AVFilterContext  *ctx = inlink->dst;
+    TonemapCUDAContext *s = ctx->priv;
+    CudaFunctions *cu = s->hwctx->internal->cuda_dl;
+    CUcontext dummy, cuda_ctx = s->hwctx->cuda_ctx;
+    AVBPrint constants;
+    CUlinkState link_state;
+    void *cubin;
+    size_t cubin_size;
+    double rgb_matrix[3][3], yuv_matrix[3][3], rgb2rgb_matrix[3][3];
+    const struct LumaCoefficients *in_coeffs, *out_coeffs;
+    enum AVColorSpace in_spc = s->in_spc, out_spc = s->in_spc;
+    enum AVColorPrimaries in_pri = s->in_pri, out_pri = s->out_pri;
+    enum AVColorTransferCharacteristic in_trc = s->in_trc, out_trc = s->out_trc;
+    char info_log[4096], error_log[4096];
+    CUjit_option options[] = {CU_JIT_INFO_LOG_BUFFER, CU_JIT_ERROR_LOG_BUFFER, CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES, CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES};
+    void *option_values[]  = {&info_log,              &error_log,              (void*)(intptr_t)sizeof(info_log), (void*)(intptr_t)sizeof(error_log)};
+
+    extern char tonemap_ptx[];
+
+    if (in_spc == AVCOL_SPC_UNSPECIFIED)
+        in_spc = AVCOL_SPC_BT2020_NCL;
+    if (out_spc == AVCOL_SPC_UNSPECIFIED)
+        out_spc = AVCOL_SPC_BT709;
+
+    if (in_pri == AVCOL_PRI_UNSPECIFIED)
+        in_pri = AVCOL_PRI_BT2020;
+    if (out_pri == AVCOL_PRI_UNSPECIFIED)
+        out_pri = AVCOL_PRI_BT709;
+
+    if (in_trc == AVCOL_TRC_UNSPECIFIED)
+        in_trc = AVCOL_TRC_SMPTE2084;
+    if (out_trc == AVCOL_TRC_UNSPECIFIED)
+        out_trc = AVCOL_TRC_BT709;
+
+    if (!(in_coeffs = ff_get_luma_coefficients(in_spc)))
+        return AVERROR(EINVAL);
+
+    ff_fill_rgb2yuv_table(in_coeffs, yuv_matrix);
+    ff_matrix_invert_3x3(yuv_matrix, rgb_matrix);
+
+    if (!(out_coeffs = ff_get_luma_coefficients(out_spc)))
+        return AVERROR(EINVAL);
+
+    ff_fill_rgb2yuv_table(out_coeffs, yuv_matrix);
+
+    if ((ret = get_rgb2rgb_matrix(in_pri, out_pri, rgb2rgb_matrix)) < 0)
+        return ret;
+
+    av_bprint_init(&constants, 2048, AV_BPRINT_SIZE_UNLIMITED);
+
+    av_bprintf(&constants, ".version 3.2\n");
+    av_bprintf(&constants, ".target sm_30\n");
+    av_bprintf(&constants, ".address_size %zu\n", sizeof(void*) * 8);
+
+#define CONSTANT_A(decl, align, ...) \
+    av_bprintf(&constants, ".visible .const .align " #align " " decl ";\n", __VA_ARGS__)
+#define CONSTANT(decl, ...) CONSTANT_A(decl, 4, __VA_ARGS__)
+#define CONSTANT_M(a, b) \
+    CONSTANT(".f32 " a "[] = {%f, %f, %f, %f, %f, %f, %f, %f, %f}", \
+             b[0][0], b[0][1], b[0][2], \
+             b[1][0], b[1][1], b[1][2], \
+             b[2][0], b[2][1], b[2][2])
+#define CONSTANT_C(a, b) \
+    CONSTANT(".f32 " a "[] = {%f, %f, %f}", \
+             b->cr, b->cg, b->cb)
+
+    CONSTANT(".u32 depth_src      = %i", (int)s->in_desc ->comp[0].depth);
+    CONSTANT(".u32 depth_dst      = %i", (int)s->out_desc->comp[0].depth);
+    CONSTANT(".u32 fmt_src        = %i", (int)s->in_fmt);
+    CONSTANT(".u32 fmt_dst        = %i", (int)s->out_fmt);
+    CONSTANT(".u32 range_src      = %i", (int)s->in_range);
+    CONSTANT(".u32 range_dst      = %i", (int)s->out_range);
+    CONSTANT(".u32 trc_src        = %i", (int)in_trc);
+    CONSTANT(".u32 trc_dst        = %i", (int)out_trc);
+    CONSTANT(".u32 chroma_loc_src = %i", (int)s->in_chroma_loc);
+    CONSTANT(".u32 chroma_loc_dst = %i", (int)s->out_chroma_loc);
+    CONSTANT(".u32 tonemap_func   = %i", (int)s->tonemap);
+    CONSTANT(".f32 tone_param     = %f", s->param);
+    CONSTANT(".f32 desat_param    = %f", s->desat_param);
+    CONSTANT_M("rgb_matrix", rgb_matrix);
+    CONSTANT_M("yuv_matrix", yuv_matrix);
+    CONSTANT_A(".u8 rgb2rgb_passthrough = %i", 1, in_pri == out_pri);
+    CONSTANT_M("rgb2rgb_matrix", rgb2rgb_matrix);
+    CONSTANT_C("luma_src", in_coeffs);
+    CONSTANT_C("luma_dst", out_coeffs);
+
+    ret = CHECK_CU(cu->cuCtxPushCurrent(cuda_ctx));
+    if (ret < 0)
+        return ret;
+
+    if (s->cu_module) {
+        ret = CHECK_CU(cu->cuModuleUnload(s->cu_module));
+        if (ret < 0)
+            goto fail;
+
+        s->cu_func = NULL;
+        s->cu_module = NULL;
+    }
+
+    ret = CHECK_CU(cu->cuLinkCreate(sizeof(options) / sizeof(options[0]), options, option_values, &link_state));
+    if (ret < 0)
+        goto fail;
+
+    ret = CHECK_CU(cu->cuLinkAddData(link_state, CU_JIT_INPUT_PTX, constants.str,
+                                     constants.len, "constants", 0, NULL, NULL));
+    if (ret < 0)
+        goto fail2;
+
+    ret = CHECK_CU(cu->cuLinkAddData(link_state, CU_JIT_INPUT_PTX, tonemap_ptx,
+                                     strlen(tonemap_ptx), "tonemap.ptx", 0, NULL, NULL));
+    if (ret < 0)
+        goto fail2;
+
+    ret = CHECK_CU(cu->cuLinkComplete(link_state, &cubin, &cubin_size));
+    if (ret < 0)
+        goto fail2;
+
+    ret = CHECK_CU(cu->cuModuleLoadData(&s->cu_module, cubin));
+    if (ret < 0)
+        goto fail2;
+
+    CHECK_CU(cu->cuModuleGetFunction(&s->cu_func, s->cu_module, "tonemap"));
+    if (ret < 0)
+        goto fail2;
+
+fail2:
+    CHECK_CU(cu->cuLinkDestroy(link_state));
+
+fail:
+    CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+
+    av_bprint_finalize(&constants, NULL);
+
+    if ((intptr_t)option_values[2] > 0)
+        av_log(ctx, AV_LOG_INFO, "CUDA linker output: %.*s\n", (int)(intptr_t)option_values[2], info_log);
+
+    if ((intptr_t)option_values[3] > 0)
+        av_log(ctx, AV_LOG_ERROR, "CUDA linker output: %.*s\n", (int)(intptr_t)option_values[3], error_log);
+
+    return ret;
+}
+
+static av_cold int config_props(AVFilterLink *outlink)
+{
+    AVFilterContext *ctx = outlink->src;
+    AVFilterLink *inlink = outlink->src->inputs[0];
+    AVHWFramesContext *frames_ctx = (AVHWFramesContext*)inlink->hw_frames_ctx->data;
+    AVCUDADeviceContext *device_hwctx = frames_ctx->device_ctx->hwctx;
+    TonemapCUDAContext *s  = ctx->priv;
+    int ret;
+
+    s->hwctx = device_hwctx;
+
+    outlink->w = inlink->w;
+    outlink->h = inlink->h;
+
+    ret = init_processing_chain(ctx, outlink);
+    if (ret < 0)
+        return ret;
+
+    s->in_desc  = av_pix_fmt_desc_get(s->in_fmt);
+    s->out_desc = av_pix_fmt_desc_get(s->out_fmt);
+
+    outlink->sample_aspect_ratio = inlink->sample_aspect_ratio;
+
+    return 0;
+}
+
+static int run_kernel(AVFilterContext *ctx,
+                      AVFrame *out, AVFrame *in)
+{
+    TonemapCUDAContext *s = ctx->priv;
+    CudaFunctions *cu = s->hwctx->internal->cuda_dl;
+    FFCUDAFrame src, dst;
+    void *args_uchar[] = { &src, &dst };
+    int ret;
+
+    ret = ff_make_cuda_frame(&src, in);
+    if (ret < 0)
+        goto fail;
+
+    ret = ff_make_cuda_frame(&dst, out);
+    if (ret < 0)
+        goto fail;
+
+    if (s->peak > 0)
+        src.peak = s->peak;
+
+    dst.peak = 1.;
+
+    ret = CHECK_CU(cu->cuLaunchKernel(s->cu_func,
+                                      DIV_UP(src.width / 2, BLOCKX), DIV_UP(src.height / 2, BLOCKY), 1,
+                                      BLOCKX, BLOCKY, 1, 0, s->hwctx->stream, args_uchar, NULL));
+
+fail:
+    return ret;
+}
+
+static int do_tonemap(AVFilterContext *ctx, AVFrame *out, AVFrame *in)
+{
+    TonemapCUDAContext *s = ctx->priv;
+    AVFrame *src = in;
+    int ret;
+
+    ret = run_kernel(ctx, s->frame, src);
+    if (ret < 0)
+        return ret;
+
+    src = s->frame;
+    ret = av_hwframe_get_buffer(src->hw_frames_ctx, s->tmp_frame, 0);
+    if (ret < 0)
+        return ret;
+
+    av_frame_move_ref(out, s->frame);
+    av_frame_move_ref(s->frame, s->tmp_frame);
+
+    s->frame->width  = in->width;
+    s->frame->height = in->height;
+
+    ret = av_frame_copy_props(out, in);
+    if (ret < 0)
+        return ret;
+
+    return 0;
+}
+
+static int filter_frame(AVFilterLink *link, AVFrame *in)
+{
+    AVFilterContext       *ctx = link->dst;
+    TonemapCUDAContext      *s = ctx->priv;
+    AVFilterLink      *outlink = ctx->outputs[0];
+    CudaFunctions          *cu = s->hwctx->internal->cuda_dl;
+
+    AVFrame *out = NULL;
+    CUcontext dummy;
+    int ret = 0;
+
+    out = av_frame_alloc();
+    if (!out) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    if (!s->cu_func ||
+        s->in_range      != in->color_range ||
+        s->in_trc        != in->color_trc ||
+        s->in_pri        != in->color_primaries ||
+        s->in_spc        != in->colorspace ||
+        s->in_chroma_loc != in->chroma_location) {
+        s->in_range      = in->color_range;
+        s->in_trc        = in->color_trc;
+        s->in_pri        = in->color_primaries;
+        s->in_spc        = in->colorspace;
+        s->in_chroma_loc = in->chroma_location;
+
+        s->out_range      = AVCOL_RANGE_MPEG;
+        s->out_trc        = AVCOL_TRC_BT709;
+        s->out_pri        = AVCOL_PRI_BT709;
+        s->out_spc        = AVCOL_SPC_BT709;
+        s->out_chroma_loc = s->in_chroma_loc;
+
+        if ((ret = compile(link)) < 0)
+            goto fail;
+    }
+
+    ret = CHECK_CU(cu->cuCtxPushCurrent(s->hwctx->cuda_ctx));
+    if (ret < 0)
+        goto fail;
+
+    ret = do_tonemap(ctx, out, in);
+
+    CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+    if (ret < 0)
+        goto fail;
+
+    av_frame_free(&in);
+    return ff_filter_frame(outlink, out);
+fail:
+    av_frame_free(&in);
+    av_frame_free(&out);
+    return ret;
+}
+
+#define OFFSET(x) offsetof(TonemapCUDAContext, x)
+#define FLAGS (AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM)
+static const AVOption options[] = {
+    { "tonemap",      "tonemap algorithm selection", OFFSET(tonemap), AV_OPT_TYPE_INT, {.i64 = TONEMAP_NONE}, TONEMAP_NONE, TONEMAP_MAX - 1, FLAGS, "tonemap" },
+    {     "none",     0, 0, AV_OPT_TYPE_CONST, {.i64 = TONEMAP_NONE},              0, 0, FLAGS, "tonemap" },
+    {     "linear",   0, 0, AV_OPT_TYPE_CONST, {.i64 = TONEMAP_LINEAR},            0, 0, FLAGS, "tonemap" },
+    {     "gamma",    0, 0, AV_OPT_TYPE_CONST, {.i64 = TONEMAP_GAMMA},             0, 0, FLAGS, "tonemap" },
+    {     "clip",     0, 0, AV_OPT_TYPE_CONST, {.i64 = TONEMAP_CLIP},              0, 0, FLAGS, "tonemap" },
+    {     "reinhard", 0, 0, AV_OPT_TYPE_CONST, {.i64 = TONEMAP_REINHARD},          0, 0, FLAGS, "tonemap" },
+    {     "hable",    0, 0, AV_OPT_TYPE_CONST, {.i64 = TONEMAP_HABLE},             0, 0, FLAGS, "tonemap" },
+    {     "mobius",   0, 0, AV_OPT_TYPE_CONST, {.i64 = TONEMAP_MOBIUS},            0, 0, FLAGS, "tonemap" },
+    {     "bt2390",   0, 0, AV_OPT_TYPE_CONST, {.i64 = TONEMAP_BT2390},            0, 0, FLAGS, "tonemap" },
+    { "format", "Output format",       OFFSET(format_str), AV_OPT_TYPE_STRING, { .str = "same" }, .flags = FLAGS },
+    { "peak",      "signal peak override", OFFSET(peak), AV_OPT_TYPE_DOUBLE, {.dbl = 0}, 0, DBL_MAX, FLAGS },
+    { "param",     "tonemap parameter",   OFFSET(param), AV_OPT_TYPE_DOUBLE, {.dbl = 0}, 0, DBL_MAX, FLAGS },
+    { "desat",     "desaturation parameter",   OFFSET(desat_param), AV_OPT_TYPE_DOUBLE, {.dbl = 0.5}, 0, DBL_MAX, FLAGS },
+    { "threshold", "scene detection threshold",   OFFSET(scene_threshold), AV_OPT_TYPE_DOUBLE, {.dbl = 0.2}, 0, DBL_MAX, FLAGS },
+    { NULL },
+};
+
+static const AVClass tonemap_cuda_class = {
+    .class_name = "tonemap_cuda",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+static const AVFilterPad inputs[] = {
+    {
+        .name        = "default",
+        .type        = AVMEDIA_TYPE_VIDEO,
+        .filter_frame = filter_frame,
+    },
+    { NULL }
+};
+
+static const AVFilterPad outputs[] = {
+    {
+        .name         = "default",
+        .type         = AVMEDIA_TYPE_VIDEO,
+        .config_props = config_props,
+    },
+    { NULL }
+};
+
+AVFilter ff_vf_tonemap_cuda = {
+    .name        = "tonemap_cuda",
+    .description = NULL_IF_CONFIG_SMALL("GPU accelerated HDR-to-SDR tone mapping"),
+
+    .init          = init,
+    .uninit        = uninit,
+    .query_formats = query_formats,
+
+    .priv_size  = sizeof(TonemapCUDAContext),
+    .priv_class = &tonemap_cuda_class,
+
+    .inputs  = inputs,
+    .outputs = outputs,
+
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+};
\ No hay ningún carácter de nueva línea al final del fichero
